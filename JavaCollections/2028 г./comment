создаем дерево родители -> дати - > дети и тд.
Шаг 1:
  создаем на базе AbstractList  реализуем интерфейсы Cloneable и Serializable
Шаг 2 :
Определили методы, которые будут оперировать с нашим деревом и  написали отлов исключений (UnsupportedOperationException)       
Шаг 3:
  Вложили в класс, описывающий дерево, класс, описывающзий элементы дерева.
  назвали и вписали нужные поля. Создали конструктор
Шаг 4: 
  создаем структуру дерева и методы для оперирования над ней.  
  1. Создали метод, возвращающий родителя дерева. public String getParent(String value)
  вложили в него метод,  который отвечает за  полную коллекцию элементов и  убирает начальный элемент. private void setValidCollection()
  в  этот метод вложили метод, который проходит по дереву, начиная с элемента Entry<String> root и  перезаписывет все элементы в начальный список  private void setUpCollectoin(Entry<String> root) 
  2. Переопределяем метод добавления элементов
  обращаемся к private void setUpCollectoin
  проходим по всей коллекции: 
      проверка на возможность иметь ветви public void checkChildren()  создали метод
      добавляем новый элемент  private void creatChild(Entry<String> parent, String s)создали метод
      проверяем коллекцию  setValidCollection();
  3. Переопределяем  метод, возвращающий размер коллекции
  проверяем  и заново инициализируем коллекцию с помощью setValidCollection
  возвращаем размер листа-коллекции
Шаг 5:
  работаем с удалением элементов дерева. Для этого создаем дополнительно  remove(Object o) {}
  ищем по переданному объекту. Нашли - удаляем (возвращаем true), не нашли - вернули false
  работает только с 1м найденным элементом
  для этого создаем метод, который возвращает переданную ему коллекцию ( похожий на setUpCollection), отличие только в возвращаемом параметре.
  используем так же метод, кторый меняет статус элементов, подлежащих удалению 
private void changeNewLineRootElement(Entry<String> entry, List<Entry<String>> delList)
  Новый элемент ищется по принципу: если остались элементы справа, то выбирается соседний, если не осталось,то поднимаемся на уровень выше и ищем там самый левый.  
    в этом методе  используем следующий метод, который  ищет первый (по вертикали и горизонтали) элемент,  который не надо удалять
    private Entry<String> getUndelRoot(Entry<String> entry, List<Entry<String>> delList)
    
После сдачи задачи валидатору в подсказках остались не прописанные в нашем коде методы.



  
